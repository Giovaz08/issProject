/* Generated by AN DISI Unibo */ 
package it.unibo.roomperimeterexplorer

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Roomperimeterexplorer ( name: String, scope: CoroutineScope ) : ActorBasicFsm( name, scope){
 	
	override fun getInitialState() : String{
		return "s0"
	}
		
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		
			val mapname = "roomMap" //nome del file in cui salvare la mappa
			var Tback = 0 //tempo che impiega il robot per tornare indietro
			var NumWallsFound = 0 //numero di muri scansionati
			
			//VIRTUAL ROBOT
			var StepTime = 330 //tempo per effettuare un passo in avanti	 
			var PauseTime = 300 //tempo di pausa tra un passo e l'altro
			var PauseTimeL  = PauseTime.toLong()
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("ROOMPERIMETEREXPLORER AVVIATO")
						itunibo.planner.plannerUtil.initAI(  )
						itunibo.planner.moveUtils.showCurrentRobotState(  )
					}
					 transition( edgeName="goto",targetState="waitComand", cond=doswitch() )
				}	 
				state("waitComand") { //this:State
					action { //it:State
						println("in attesa di un comando")
					}
					 transition(edgeName="t10",targetState="detectWall",cond=whenDispatch("scanningPerimeter"))
				}	 
				state("detectWall") { //this:State
					action { //it:State
						println("")
						println("State detectWall")
						NumWallsFound++
						itunibo.planner.plannerUtil.showMap(  )
					}
					 transition( edgeName="goto",targetState="doAheadMove", cond=doswitchGuarded({(NumWallsFound<5)}) )
					transition( edgeName="goto",targetState="perimeterFound", cond=doswitchGuarded({! (NumWallsFound<5)}) )
				}	 
				state("doAheadMove") { //this:State
					action { //it:State
						println("")
						println("State doAheadMove")
						itunibo.planner.moveUtils.attemptTomoveAhead(myself ,StepTime )
					}
					 transition(edgeName="t01",targetState="stepDone",cond=whenDispatch("stepOk"))
					transition(edgeName="t02",targetState="stepFailed",cond=whenDispatch("stepFail"))
				}	 
				state("stepDone") { //this:State
					action { //it:State
						println("")
						println("State stepDone")
						itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
						delay(PauseTimeL)
						println("MyRobotPos=(${itunibo.planner.plannerUtil.getPosX()}, ${itunibo.planner.plannerUtil.getPosY()}, ${itunibo.planner.moveUtils.getDirection(myself)})")
					}
					 transition( edgeName="goto",targetState="doAheadMove", cond=doswitch() )
				}	 
				state("stepFailed") { //this:State
					action { //it:State
						println("")
						println("State stepFailed")
						println("************************ WALL FOUND! ************************")
						val MapStr = itunibo.planner.plannerUtil.getMapOneLine()
						forward("modelUpdate", "modelUpdate(roomMap,$MapStr)" ,"resourcemodel" ) 
						if( checkMsgContent( Term.createTerm("stepFail(R,T)"), Term.createTerm("stepFail(Obs,Time)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								Tback=payloadArg(1).toString().toInt() / 4
								println("stepFailed ${payloadArg(1).toString()}")
						}
						itunibo.planner.moveUtils.backToCompensate(myself ,Tback, PauseTime )
						itunibo.planner.plannerUtil.wallFound(  )
						itunibo.planner.moveUtils.rotateLeft(myself ,PauseTime )
					}
					 transition( edgeName="goto",targetState="detectWall", cond=doswitch() )
				}	 
				state("perimeterFound") { //this:State
					action { //it:State
						println("")
						println("State perimeterFound")
						itunibo.planner.moveUtils.saveMap(myself ,mapname )
						println("FINAL MAP")
						itunibo.planner.moveUtils.showCurrentRobotState(  )
						var mapMaxX = itunibo.planner.moveUtils.getMapDimX() - 2
								var mapMaxY = itunibo.planner.moveUtils.getMapDimY() - 2
						solve("assert(fridge('${mapMaxX}',0))","") //set resVar	
						solve("assert(dishWasher('${mapMaxX}','${mapMaxY}'))","") //set resVar	
						solve("assert(pantry(0,'${mapMaxY}'))","") //set resVar	
						solve("consult('domesticAppliancesPos.pl')","") //set resVar	
						if(currentSolution.isSuccess()) { solve("fridge(X,Y)","") //set resVar	
						if(currentSolution.isSuccess()) { delay(100) 
						println("fridge at: ${getCurSol("X").toString()}, ${getCurSol("Y").toString()}")
						forward("sendInfoPos", "sendInfoPos(fridge,${getCurSol("X")},${getCurSol("Y")})" ,"navi" ) 
						 }
						solve("dishWasher(X,Y)","") //set resVar	
						if(currentSolution.isSuccess()) { delay(100) 
						println("dishWasher at: ${getCurSol("X").toString()}, ${getCurSol("Y").toString()}")
						forward("sendInfoPos", "sendInfoPos(dishWasher,${getCurSol("X")},${getCurSol("Y")})" ,"navi" ) 
						 }
						solve("pantry(X,Y)","") //set resVar	
						if(currentSolution.isSuccess()) { delay(100) 
						println("pantry at: ${getCurSol("X").toString()}, ${getCurSol("Y").toString()}")
						forward("sendInfoPos", "sendInfoPos(pantry,${getCurSol("X")},${getCurSol("Y")})" ,"navi" ) 
						 }
						 }
						forward("endPerimeter", "endPerimeter" ,"rbr" ) 
					}
				}	 
			}
		}
}
