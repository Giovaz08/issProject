System navigator 
mqttBroker "localhost" : 1883  

/* --------------------------- */  
// EVENTI
/* --------------------------- */
  
//REQUISITO: the Maitre is able at any time to use his/her smart-phone to stop or reactivate an activated task.
//da frontend
Event stop : stop(N) 						
Event reactivate : reactivate(N)

/* --------------------------- */
// DISPATCH
/* --------------------------- */

//a resourcemodel (robotMinds)
Dispatch modelUpdate : modelUpdate(TARGET,VALUE)
Dispatch modelChange : modelChange(TARGET, VALUE) 

//da onestepahead (robotMinds)
Dispatch stepOk : stepOk(N) 
Dispatch stepFail : stepFail(R,T) 						//(R=ok|obstacle, T=time)

//da frontend
Dispatch staticStartTheSystem : staticStartTheSystem(N) 

//da scanningroom 
Dispatch robotPosition : robotPosition(X,Y,D) 			//Utilizzato per far sapere a navi la posizione del robot dopo l'esecuzione di scanningroom

//auto msg
Dispatch startGoal : startGoal(N)	

//da clear,	prepare, addFood					
Dispatch reachAppliance : reachAppliance(MIT, NAME)
Dispatch reachTable : reachTable(MIT) 			

//da clear,	prepare, addFood e scanningRoom
Dispatch goHome : goHome(MIT) 							

//a prepare
Dispatch pantryReached : pantryReached(N) 

//a clear, 	prepare, addFood				
Dispatch tableReached : tableReached(N) 				
Dispatch fridgeReached : fridgeReached(N)

//a clear
Dispatch dishWasherReached : dishWasherReached(N) 

//a clear, 	prepare, addFood, rbr	
Dispatch homeReached : homeReached(MIT) 				

//da scanningRoom e findTable
Dispatch sendInfoPos : sendInfoPos(NAME,X,Y) 

/* --------------------------- */
// CONTESTI
/* --------------------------- */

Context ctxNavigator 	ip [host="localhost" port=9002] +mqtt
Context ctxDummyForMind ip [host="localhost" port=8035] +mqtt

/* --------------------------- */
// ATTORI
/* --------------------------- */

ExternalQActor resourcemodel context ctxDummyForMind

QActor navi context ctxNavigator {     
	["
	val mapname = \"roomMapWithTable\"
	val staticMapName = \"staticRoomMap\"
	var mapEmpty = true
	var Curmove = \"\" 
	var curmoveIsForward = false 
	
	//REAL ROBOT
	//var StepTime   = 1000 	 
	//var PauseTime  = 500 
	
	//VIRTUAL ROBOT
	var StepTime   = 350
	var PauseTime  = 500
	
	var PauseTimeL  = PauseTime.toLong()
	
	var GoalX = 0
	var GoalY = 0
	var ReachDestination = \"\"
	var ToSend = \"\"
	
	var Sender = \"\" //nel nostro caso è anche il currentTask
	var Tback = 0
	"]
	
	State s0 initial{
		println("NAVI AVVIATO")
		solve(consult("moves.pl"))
		solve(consult("domesticAppliancesPos.pl"))
 		run itunibo.planner.plannerUtil.initAI() 
	}
	Goto waitCmd

	State waitCmd{
		println("in attesa di un comando")
    }
    Transition t0 	whenMsg reachAppliance -> planPathToAppliance 	//da clear,	prepare, addFood
				  	whenMsg reachTable -> planPathToTable			//da clear,	prepare, addFood
				  	whenMsg goHome -> returnHome					//da clear,	prepare, addFood e scanningRoom
				  	whenMsg sendInfoPos -> savePos					//da scanningRoom e findTable (per aggiornare la KB degli elettrodomestici + tavolo)
				  	whenMsg robotPosition -> updateRobotPos 		//da scanningroom (per aggiornare la posizione corrente del robot)
				  	whenMsg staticStartTheSystem -> staticSetupRoom //da rbr 
	
	//Caricamento mappa e posizioni degli elettrodomestici statica				  
	State staticSetupRoom{
		println("")
		println("State staticSetupRoom")
		
		solve(consult("staticDomesticAppliancesPos.pl")) 
		run itunibo.planner.moveUtils.loadRoomMap(myself, staticMapName)	    
		["
		mapEmpty = itunibo.planner.moveUtils.mapIsEmpty()
		"]		
 		if "!mapEmpty" {
			["
			val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
			"]
 			forward resourcemodel -m modelUpdate : modelUpdate(roomMap, $MapStr)
 			delay 1000
 			run itunibo.frontend.frontendSupport.updateFrontend(myself, "systemStarted")  
 		}
	}
	Goto warning if "mapEmpty" else waitCmd
	
	State warning{
		println("========================================")
		println("WARNING: static map not found")
		println("========================================")
	}
	
	//in questo stato non fa nulla, aspetta solo reactivate	  
	State handleEventStop {
		println("")
		println("State handleEventStop")
	}
	Transition t5 whenEvent reactivate -> handleEventReactivate //da frontend
	
	//in questo stato non fa nulla, semplicemente aspetta uno stepOk/Fail per far ripartire il robot
	State handleEventReactivate {
		println("")
		println("State handleEventReactivate")
	}
	Transition t6 	whenMsg stepOk   -> handleStepOk   
					whenMsg stepFail -> handleStepFail
		  
	State updateRobotPos{
		println("")
		println("State updateRobotPos")
		println("Ricevuta posizione aggiornata del robot")
		onMsg(robotPosition : robotPosition(X, Y, D)) {
			run itunibo.planner.moveUtils.loadRoomMap( myself, mapname )	
			["
			var x = payloadArg(0).toString().toInt()
			var y = payloadArg(1).toString().toInt()
			var d = payloadArg(2).toString()
			itunibo.planner.plannerUtil.resetRobotPos(x, y, itunibo.planner.plannerUtil.getPosX(), itunibo.planner.plannerUtil.getPosY(), d )
			"]
			run itunibo.planner.moveUtils.showCurrentRobotState()
		 	["
			val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
			"]
		 	forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)
		}
	}
	Goto waitCmd
				  
	State savePos{
		println("")
		println("State savePos")
		onMsg(sendInfoPos : sendInfoPos(NAME, X, Y)) {
			println("Posizione da salvare: ${payloadArg(0).toString()} ${payloadArg(1).toString()} ${payloadArg(2).toString()}")
			["
			var salvaX = payloadArg(1).toInt()
			var salvaY = payloadArg(2).toInt()
			when( payloadArg(0).toString()) {
		  		\"table\" ->"] solve(assert(table("${salvaX}", "${salvaY}")))
		    	["\"fridge\" ->"] solve(assert(fridge("${salvaX}", "${salvaY}")))
			    ["\"pantry\" ->"] solve(assert(pantry("${salvaX}", "${salvaY}")))
			    ["\"dishWasher\" ->"] solve(assert(dishWasher("${salvaX}", "${salvaY}")))
			["}"]				
		}
	}
	Goto waitCmd
	
	//Inizia a pianificare il percorso all'elettrodomestico o mobile scelto	  			
	State planPathToAppliance{
		println("")
		println("State planPathToAppliance")
		onMsg(reachAppliance : reachAppliance(MIT, NAME)){
			["
			Sender = payloadArg(0).toString()
			ReachDestination = payloadArg(1).toString()
			"]
			println("Ricevuto messaggio per raggiungere ${ReachDestination} da ${Sender}")
			["
			var destinazioneProlog = ReachDestination + \"(X,Y)\"
			"]
			println("${destinazioneProlog}")
			["
			solve(destinazioneProlog,\"\")
			"] 
			ifSolved {
				println("${ReachDestination}: ${getCurSol(\"X\")}, ${getCurSol(\"Y\")}")
				["
				GoalX = Integer.parseInt(getCurSol(\"X\").toString().replace(\"'\", \"\"))
			 	GoalY =  Integer.parseInt(getCurSol(\"Y\").toString().replace(\"'\", \"\"))
			 	ToSend = \"goal(${ReachDestination.toUpperCase()} (${GoalX}, ${GoalY}))\"
				"]
			 	run utils.writeLog("GOAL: $ReachDestination | $GoalX, $GoalY")
			 	//Emit per mqttUtils.js
			 	run itunibo.frontend.frontendSupport.updateGoalToFrontend(myself, ToSend)
				forward navi -m startGoal : startGoal
			}	
		}
	}
	Transition t1 whenMsg startGoal -> reachRequestedGoal
	
	State returnHome{
		println("")
		println("State returnHome")
		onMsg(goHome : goHome(MIT)) {
			println("Ricevuto messaggio per tornare ad RH")
			["
			GoalX = 0
		 	GoalY = 0
			ReachDestination = \"RH\"
			Sender = payloadArg(0).toString()
			ToSend = \"goal(${ReachDestination.toUpperCase()} (${GoalX}, ${GoalY}))\"
			"]
			
			println("Ricevuto messaggio per raggiungere ${ReachDestination} da ${Sender}")
			
			run utils.writeLog("GOAL: $ReachDestination | $GoalX, $GoalY") 
			//Emit per mqttUtils.js
	 		run itunibo.frontend.frontendSupport.updateGoalToFrontend(myself, ToSend)
			forward navi -m startGoal : startGoal
		}
	}
	Transition t2 whenMsg startGoal -> reachRequestedGoal
	
	//Inizia a pianificare il percorso verso il tavolo
	State planPathToTable{
		println("")
		println("State planPathToTable")
		onMsg(reachTable : reachTable(MIT)){
			["
			Sender = payloadArg(0).toString() //
			"]
			println("Ricevuto messaggio per raggiungere table da ${Sender}")
		}
		
	 	["
		var bestNum = 100
		"]
		solve(posTable(L))
		//Si calcola la posizione ottimale del tavolo da raggiungere
		ifSolved {
			["
			var listaPosizioniTavolo = getCurSol(\"L\").toString().replace(\"[\", \"\")
			listaPosizioniTavolo = listaPosizioniTavolo.toString().replace(\"]\", \"\")
			listaPosizioniTavolo = listaPosizioniTavolo.replace(Regex(\"\"\"[$,.''(]\"\"\"), \"\").dropLast(1)
			var listaPos = listaPosizioniTavolo.split(')')
			for(i in listaPos){
				var X = Integer.parseInt(i[0].toString())
		 		var Y = Integer.parseInt(i[1].toString())
			"]
		 		run itunibo.planner.plannerUtil.setGoal(X,Y)
				run itunibo.planner.plannerUtil.doPlan()
				["
				var num = itunibo.planner.plannerUtil.getActions().lastIndex
				if(num < bestNum){
					bestNum = num
					GoalX = X
					GoalY = Y
				}
			}
				"]
		}
		run itunibo.planner.plannerUtil.resetGoal(GoalX,GoalY)
		["
		ReachDestination = \"table\"
		ToSend = \"goal(${ReachDestination.toUpperCase()} (${GoalX}, ${GoalY}))\"
		"]
		run utils.writeLog("GOAL: $ReachDestination | $GoalX, $GoalY")
		//Emit per mqttUtils.js
	 	run itunibo.frontend.frontendSupport.updateGoalToFrontend(myself, ToSend)
		forward navi -m startGoal : startGoal
	}
	Transition t3 whenMsg startGoal -> reachRequestedGoal
	 
	State reachRequestedGoal{
		println("")
		println("State reachRequestedGoal")
		["
		val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
		"]
		forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)
 	}  
	Goto makeThePlan
	
	State makeThePlan{
		println("")
		println("State makeThePlan")
 		run itunibo.planner.plannerUtil.setGoal(GoalX,GoalY)
  		run itunibo.planner.moveUtils.doPlan( myself )
   	} 
	Goto executePlannedActions
		
	State executePlannedActions{ 
		println("")     
		println("State executePlannedActions")
		solve(move(M)) 
		ifSolved {  
			["
			Curmove = getCurSol(\"M\").toString() 
            curmoveIsForward=(Curmove == \"w\")
			"]
		} 
		else { 
			["
			Curmove = \"\" 
			curmoveIsForward=false
			"]
		}   
 	} 
 	Goto checkAndDoAction if "(Curmove.length>0) " else goalOk
  	
	State checkAndDoAction{	 }
	Goto doForwardMove if "curmoveIsForward" else doRotation
	
	State doRotation{
		println("")
		println("State doRotation")
		run itunibo.planner.moveUtils.rotate(myself, Curmove, PauseTime)
		solve( retract( move(M) ) ) //tolgo dal piano la mossa che ho appena fatto
  	}
	Goto executePlannedActions 
	
 	State doForwardMove{
 		println("")
		println("State doForwardMove")
 		delayVar PauseTimeL
 		run itunibo.planner.moveUtils.attemptTomoveAhead(myself, StepTime)
	} 
	Transition t4	whenEvent stop -> handleEventStop 	//da frontend
					whenMsg stepOk -> handleStepOk   
				  	whenMsg stepFail -> handleStepFail
    
	State handleStepOk{
		println("")
		println("State handleStepOk")
 		run itunibo.planner.moveUtils.updateMapAfterAheadOk(myself)
 		solve( retract( move(M) ) ) //tolgo dal piano la mossa che ho appena fatto
 		run itunibo.planner.moveUtils.showCurrentRobotState()
	}
	Goto executePlannedActions
	
 	State handleStepFail{   
 		println("") 
 		println("State handleStepFail")
		
		forward resourcemodel -m modelChange : modelChange(robot, h)
		
		onMsg(stepFail : stepFail(Obs,Time)) {
			["
			Tback = payloadArg(1).toString().toInt()
			"]
 		}
 		delay 100
 		   
		run itunibo.planner.moveUtils.showCurrentRobotState()
	 	run itunibo.planner.moveUtils.backToCompensate(myself, Tback, PauseTime)  
	}
	Goto avoidObstacle
	
	State avoidObstacle{
		println("") 
 		println("State avoidObstacle")
 		delay 3000
 		//sviluppi futuri se si vuole cambiare strategia
	}
	Goto doForwardMove
	
	State goalOk {
 		println("")  
		println("State goalOk")
		//Funzione di utility per impostare la direzione del robot quando arriva ad una risorsa domestica
		run utils.controlDirection(myself, ReachDestination, GoalX, GoalY)
		run itunibo.planner.moveUtils.showCurrentRobotState()
 		["
		val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()
		"]
	 	forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)
	 	run itunibo.planner.plannerUtil.saveMap(mapname)
	 	run utils.writeLog("GOAL REACHED: $ReachDestination | ${itunibo.planner.plannerUtil.getPosX()}, ${itunibo.planner.plannerUtil.getPosY()}")
	 	delay 500
	 	["
		when(ReachDestination) {
	  		\"table\" -> forward(\"tableReached\", \"tableReached\", \"$Sender\")
	    	\"RH\" -> forward(\"homeReached\", \"homeReached(navi)\", \"$Sender\")
		    \"pantry\" -> forward(\"pantryReached\", \"pantryReached\", \"$Sender\")
		    \"fridge\" -> forward(\"fridgeReached\", \"fridgeReached\", \"$Sender\")
			\"dishWasher\" -> forward(\"dishWasherReached\", \"dishWasherReached\", \"$Sender\")
		}
		"]
 	}
 	Goto waitCmd
}	